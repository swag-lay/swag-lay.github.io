---
title: redis持久化
date: 2024-04-17 10:25:12
categories:
- redis
tags:
---

# AOF的持久化
AOF日志：每执行一条写操作，以追加的方式写入到一个文件中，然后重启redis的时候，先去读取这个文件里的命令，并且执行它；**注意只会记录写操作命令，读操作命令是不会被记录的**
只记录写命令的好处：
1. 避免额外的检查开销
2. 不会阻塞当前写操作命令的执行

redis写入aof日志的过程：

![img](..\images\4eeef4dd1bedd2ffe0b84d4eaa0dbdea.png)

三种写回aof策略，也就是上图中的第三步系统调用的过程
- always：写操作执行完，同步将aof日志写入磁盘
- everysec：写操作执行完，将命令写入aof文件的内核缓存区，然后每隔一秒将缓冲区内容写回磁盘
- no：不由redis控制写回磁盘的时机，交给操作系统决定

## AOF的重写机制
为了避免aof文件越写越大，提供了**aof重写机制**
在重写时，读取当前数据库中的所有键值对，将每一条键值对用命令记录到新的aof文件中，等所有记录完后，将新的aof文件替换掉现有的aof文件，其实就是减少反复修改的记录。

redis的重写aof过程是由后台子程序bgrewriteaof来完成，

# RDB快照
rdb快照记录某一瞬间的内存数据
redis提供两个命令来生成rdb文件，save和bgsave，
- save，会在主线程里生成rdb文件，由于和执行操作命令在同一个线程，写入时间长会阻塞主线程
- bgsave：创建子进程来生成rdb文件，避免主线程的阻塞

redis的快照是全量快照，也就是每次执行快照，就是把内存中的所有数据记录到磁盘中


## 大key对日志的影响
aof和rdb过程中，都会fork一个子进程，其中负责一份页表给子进程指向同一个内存空间，当页表很大，fork就会发生阻塞。
当父进程或者子进程向内存发起写操作，cpu触发**写保护中断**，将进程权限设置为可读写，然后进行写操作，这个过程称为**写时复制**。会将物理内存复制一份，进行修改，如果key较大，复制过程就会阻塞。
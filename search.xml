<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql-index</title>
      <link href="/2023/08/29/mysql-index/"/>
      <url>/2023/08/29/mysql-index/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql-索引"><a href="#mysql-索引" class="headerlink" title="mysql-索引"></a>mysql-索引</h1><p>索引是帮助mysql<strong>高效获取数据的数据结构（有序）</strong>。这些数据结构以某种方式引用（指向）数据，这也就可以在这些数据结构上是实现高级查找算法，这种数据结构就是索引。</p><p>优势：提高数据检索的效率，降低数据的io成本，降低数据库排序的成本，降低cpu的消耗。</p><p>缺点：索引列需要空间，降低了更新表的速度。</p><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>相对于B树区别：所有的数据都会出现在叶子节点，叶子节点形成一个单向链表</p><p>Mysql索引结构对经典B+树进行了优化，在原B+树基础上，增加了一个指向相邻叶子节点的链表指针，形成了带有顺序指针的B+树，提高区间访问的效率。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>用的链地址法处理冲突</p><p>特点：</p><p>​hash索引只能用于对等比较（&#x3D;，in），不支持范围查询（between，&gt;，&lt;，…）</p><p>​无法利用索引完成排序操作</p><p>​查询效率高，通常只需要以此检索就可以了，效率通常高于b+树</p><p>mysql中，支持hash索引的是Memory引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+树索引在指定条件下自动构建的。</p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>primary</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>unique</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>fulltext</td></tr></tbody></table><p>在innodb中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引（clustered index）</td><td>将数据存储和索引放到了一块，索引结构中的叶子节点保持了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>二级索引（secondary index）</td><td>将数据和索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>聚集索引选取规则：</p><p>​以下顺序：主键索引-&gt;唯一索引-&gt;自动生成一个rowid作为隐藏的聚集索引。</p><h2 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h2><p>创建索引</p><pre><code class="mysql">create [unique|fulltext] index index_name on table_name (index_col_name,...);</code></pre><p>查看索引</p><pre><code class="mysql">show index from table_name;</code></pre><p>删除索引</p><pre><code class="mysql">drop index index_name on table_name;</code></pre><h2 id="sql性能分析"><a href="#sql性能分析" class="headerlink" title="sql性能分析"></a>sql性能分析</h2><p>sql执行频率：mysql客户端连接成功后，通过show [session|global] status命令可以提供服务器状态信息。可以查看当前数据库的insert，update，delete，select的访问频次</p><pre><code class="mysql">show global status like &#39;Com____&#39;;</code></pre><p>慢查询日志</p><p>profile详情</p><pre><code class="mysql"># 查看每一条sql的耗时基本情况show profiles;# 查看指定query_id的sql语句每个阶段的耗时情况show profile for query query_id;# 查看指定query_id的sql语句cpu的使用情况show profile cpu for query_id;</code></pre><p>explain执行计划</p><p>explain或者desc命令获取mysql如果执行select语句的信息，包括在select语句执行过程中表如果连接和连接的顺序</p><pre><code class="mysql"># 直接在select语句之前加上关键字explain/descexplain ...</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-storage-engine</title>
      <link href="/2023/08/29/mysql-engine/"/>
      <url>/2023/08/29/mysql-engine/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql-存储引擎"><a href="#mysql-存储引擎" class="headerlink" title="mysql-存储引擎"></a>mysql-存储引擎</h1><h2 id="mysql体系结构"><a href="#mysql体系结构" class="headerlink" title="mysql体系结构"></a>mysql体系结构</h2><p><img src="/..%5Cimages%5Cimage-mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="image-20230829093941681"></p><p>连接层，服务层，引擎层，存储层</p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎是存储数据，建立索引，更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎可以被称为表类型。</p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>兼顾高可靠性和高性能的通用存储引擎，在mysql5.5之后，InnoDB是默认的存储引擎。</p><p>特点：</p><p>DML操作遵循ACID模型，支持<strong>事务</strong>；</p><p><strong>行级锁</strong>，提高并发访问性能；</p><p>支持外键foreign key约束，保证数据的完整性和正确性。</p><p>文件：</p><p>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm，sdi），索引和数据。</p><p>参数：innodb_file_per_table</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>mysql早期的默认存储引擎。</p><p>特点：</p><p>不支持事务，不支持外键</p><p>支持表锁，不支持行锁</p><p>访问速度快</p><p>文件：</p><p>xxx.sdi：存储表结构信息</p><p>xxx.MYD：存储数据<br>xxx.MYI：存储索引</p><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>表数据存储在内存中，由于受到硬件问题，或断电问题的影响，只能将这些表作为临时表或缓存使用</p><p>特点：</p><p>内存存放</p><p>hash索引（默认）</p><p>文件：</p><p>xxx.sdi：存储表结构信息</p><p><img src="/..%5Cimages%5Cimage-%E5%BC%95%E6%93%8E%E7%89%B9%E7%82%B9.png" alt="image-20230829100341545"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>transaction_sql</title>
      <link href="/2023/08/28/transaction-sql/"/>
      <url>/2023/08/28/transaction-sql/</url>
      
        <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><h2 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h2><p>查看&#x2F;设置事务提交方式</p><pre><code class="mysql">select @@autocommit;set @@autocommit=0;#设置为手动改提交</code></pre><p>提交事务</p><pre><code class="mysql">commit;</code></pre><p>回滚事务</p><pre><code class="mysql">rollback；</code></pre><p>开启事务</p><pre><code class="mysql">start transaction 或 begin;</code></pre><h2 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h2><p>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</p><p>一致性（Consistency）：事务完成时，必须使所有的数据都保存一致状态。</p><p>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下允许。</p><p>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p><h2 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h2><p>脏读：一个事务读到另一个事务还没有提交的数据</p><p>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称为不可重复读</p><p>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了幻读</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>repeatable read（默认）</td><td>×</td><td>×</td><td>√</td></tr><tr><td>serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><pre><code class="mysql">-- 查看事务隔离级别select @@transaction_isolation;-- 设置事务隔离级别set [session|global] transaction isolation level &#123;read uncommitted | read committed | repeatabel read | serializable&#125;</code></pre><p>事务隔离级别越高，数据越安全，但安全越低。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>select_tables</title>
      <link href="/2023/08/28/select-tables/"/>
      <url>/2023/08/28/select-tables/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql多表查询"><a href="#mysql多表查询" class="headerlink" title="mysql多表查询"></a>mysql多表查询</h1><p>概述：各个表结构之间存在着多种联系，基本上分为三种：</p><p>一对多（多对一）：</p><p>​在多的一方建立外键，指向一的一方的主键（比如部门和员工的关系）</p><p>多对多</p><p>​建立第三种中间表，中间表至少包含两个外键，分别关联两方主键（例如学生和课程的关系）</p><p>一对一</p><p>​多用于单边拆分，将一张表的基础字段放在一张表中，其他详细字段放在另一张表中，以提升操作效率</p><p>​在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（unique）</p><h2 id="多表查询分类"><a href="#多表查询分类" class="headerlink" title="多表查询分类"></a>多表查询分类</h2><h3 id="连接分类"><a href="#连接分类" class="headerlink" title="连接分类"></a>连接分类</h3><h4 id="内连接："><a href="#内连接：" class="headerlink" title="内连接："></a>内连接：</h4><p>相当于查询A，B交集部分数据</p><p>隐式内连接</p><pre><code class="mysql">select .. from .. where 条件...;</code></pre><p>显式内连接</p><pre><code>select .. from 表1 [inner] join 表2 on 连接条件;</code></pre><h4 id="外连接："><a href="#外连接：" class="headerlink" title="外连接："></a>外连接：</h4><p>左外连接：查询左表所有数据，以及两张表交集部分数据</p><pre><code class="mysql">select .. from 表1 left [outer] join 表2 on .. #相当于查询表1（左表）的所有数据 包含 表1和表2交集部分的数据</code></pre><p>右外连接：查询右表所有数据，以及两张表交集部分数据</p><pre><code class="mysql">select .. from .. right [outer] join .. on .. #相当于查询表2（右表）的所有数据 包含 表1和表2交集部分的数据</code></pre><h4 id="自连接："><a href="#自连接：" class="headerlink" title="自连接："></a>自连接：</h4><p>当前表与自身的连接查询，自连接必须使用表别名。</p><p>自连接可以用内连接和外连接。</p><pre><code class="mysql">select .. from 表a 别名a join 表a 别名b on 条件 ..;</code></pre><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>sql语句中嵌套select语句，称为嵌套查询，又称子查询</p><pre><code class="mysql">select * from t1 where column1=(select column1 from t2);</code></pre><p>子查询外部的语句可以是insert&#x2F;update&#x2F;delete&#x2F;select中的任意一个</p><p>根据子查询结果不同，分为：</p><p>标量子查询（子查询结果为单个值）</p><p>列子查询（子查询结果为一列）</p><p>​常用操作符：in，not in，any，some ，all</p><p>行子查询（子查询结果为一行）</p><p>​常用操作符：&#x3D;，&lt;&gt;，in，not in</p><p>表子查询（子查询结果为多行多列）</p><p>​常用操作符：in</p><p>根据子查询位置，分为：where之后，from之后，select之后</p><h2 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h2><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集</p><p>union all会把所有的查询直接联合，union会去重</p><pre><code class="mysql">select .. from ..union [all]select .. from ..;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>constraint</title>
      <link href="/2023/08/28/constraint/"/>
      <url>/2023/08/28/constraint/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql约束"><a href="#mysql约束" class="headerlink" title="mysql约束"></a>mysql约束</h1><p>约束是作用于表中字段上的规则，用于限制存储在表中的数据。为了保证数据库中数据的正确，有效性和完整性。</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>not null</td></tr><tr><td>唯一约束</td><td>唯一，不重复的</td><td>unique</td></tr><tr><td>主键约束</td><td>唯一标识，要求非空且唯一</td><td>primary key</td></tr><tr><td>默认</td><td></td><td>default</td></tr><tr><td>检查约束（8.0.16之后）</td><td>保证字段值满足某一个条件</td><td>check</td></tr><tr><td>外键约束</td><td>用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td><td>foreign key</td></tr></tbody></table><p>注意：约束是作用于表中字段上的，可以在创建表&#x2F;修改表的时候添加约束。</p><p>外键约束：</p><pre><code class="mysql">create table 表名(    字段名 数据类型,    ...    [constraint] [外键名称] foreign key(外键字段名) references 主表(主表列名));-- 添加外键alter table 表名 add constraint 外键名称 foreign key(外键字段名) references 主表(主表列名);-- 删除外键alter table 表名 drop foreign key 外键名称;</code></pre><p>删除&#x2F;更新行为</p><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>no action</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。（与restrict一致）</td></tr><tr><td>restrict</td><td>。。。 ，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。（与no action一致）</td></tr><tr><td>cascade</td><td>。。。，首先检查该记录是否有对应外键，如果有，则也删除&#x2F;更新外键在子表中的记录</td></tr><tr><td>set null</td><td>。。。，首先检查该记录是否有对应外键，如果有则设置子表中该外键为null（这就要求该外键允许曲null）</td></tr><tr><td>set default</td><td>父表有变更时，子表将外键列设置为一个默认的值（Innodb不支持）</td></tr></tbody></table><pre><code class="mysql">alter table 表名 add constraint 外键名称 foreign key (外键名称) references 主表名（主表字段名） on update cascade on delete cascade;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-funs</title>
      <link href="/2023/08/28/mysql-funs/"/>
      <url>/2023/08/28/mysql-funs/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql中的函数"><a href="#mysql中的函数" class="headerlink" title="mysql中的函数"></a>mysql中的函数</h1><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><pre><code class="mysql">concat(s1,s2,...,sn) #字符串拼接lower(str) 将str转换为小写upper(str) 将str转换为大写lpad(str,n,pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度rpad(str,n,pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度trim(str) 去掉字符串头部和尾部的空格substring(str,start,len) 返回从字符串str从start位置起len个长度的字符串</code></pre><h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><pre><code class="mysql">ceil(x) 向上取整floor(x) 向下取整mod(x,y) 返回x/y的模rand() 返回0-1内的随机数round(x,y) 求参数x的四舍五入的值，保留y位小数</code></pre><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><pre><code class="mysql">curdate() 当前日期curtime() 当前时间now() 返回当前日期和时间year(date) 获取指定date的年份month(date) 获取指定date的月份day(date) 获取指定date的日期date_add(date,interval expr type) 返回一个日期/时间值加上一个时间间隔expr后的时间值datediff(date1,date2) 返回起始时间date1和结束时间date2之间的天数</code></pre><h2 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h2><pre><code class="mysql">if(value,t,t) 如果value为true，则返回t，否则返回fifnull(value1,value2) 如果value1不为空，返回value1，否则返回value2case when [val1] then [res1] ...else [default] end 如果val1为true，返回res1，否则返回default默认值case [expr] when [val1] then [res1] ...else [default] end 如果expr的值等于val1，返回res1，否则返回default默认值</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-dcl</title>
      <link href="/2023/08/25/mysql-dcl/"/>
      <url>/2023/08/25/mysql-dcl/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库基本操作-dcl"><a href="#数据库基本操作-dcl" class="headerlink" title="数据库基本操作-dcl"></a>数据库基本操作-dcl</h1><p>dcl：data control language，数据控制语言，用来管理数据库用户，控制数据库的访问权限。</p><h2 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h2><p>查询用户</p><pre><code class="mysql">use mysql；select * from user；</code></pre><p>创建用户</p><pre><code class="mysql">create user &#39;用户名&#39;@&#39;主机名&#39; identified by &#39;密码&#39;；</code></pre><p>修改用户密码</p><pre><code class="mysql">alter user &#39;用户名&#39;@&#39;主机名&#39; identified with mysql_native_password by &#39;新密码&#39;;</code></pre><p>删除用户</p><pre><code class="mysql">drop user &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>注意：主机名可以用%</p><h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><p>查询权限</p><pre><code class="msyql">show grants for &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>授予权限</p><pre><code class="mysql">grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>撤销权限</p><pre><code class="mysql">revoke 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-dql</title>
      <link href="/2023/08/25/mysql-dql/"/>
      <url>/2023/08/25/mysql-dql/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql基本操作-dql"><a href="#mysql基本操作-dql" class="headerlink" title="mysql基本操作-dql"></a>mysql基本操作-dql</h1><p>dpl：data query language，用来查询数据库中表的记录。</p><p>语法：</p><pre><code class="mysql">select     字段列表from    表名列表where    条件列表group by    分组字段列表having    分组后条件列表order by    排序字段列表limit    分页参数</code></pre><ul><li><p>基本查询</p><pre><code class="mysql">select 字段列表 from 表名;select * from 表名;select 字段1[as 别名]... from 表名;select distinct 字段列表 from 表名;#去除重复操作</code></pre></li><li><p>条件查询（where）</p></li><li><p>聚合函数（count，max，min，avg，sum）</p><p>将一列数据作为一个整体，进行纵向计算（null值不参与聚合函数的运算）</p><pre><code class="mysql">select 聚合函数(字段列表) from 表名;</code></pre></li><li><p>分组查询（group by）</p><pre><code class="mysql">select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件];</code></pre><p>where和having区别</p><p>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。</p><p>判断条件不同：where不能对聚合函数进行判断，而having可以。</p></li><li><p>排序查询（order by）</p><pre><code class="mysql">select 字段列表 from 表名 order by 字段1 排序方式,字段2 排序方式;# asc 升序，desc 降序</code></pre></li><li><p>分页查询（limit）</p><pre><code>select 字段列表 from 表名 limit 起始索引,查询记录数;</code></pre></li></ul><p>dql执行顺序<br>from-&gt;where-&gt;group by-&gt;having-&gt;select-&gt;order by-&gt;limit</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-dml</title>
      <link href="/2023/08/25/mysql-dml/"/>
      <url>/2023/08/25/mysql-dml/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql数据库基本操作-dml"><a href="#mysql数据库基本操作-dml" class="headerlink" title="mysql数据库基本操作-dml"></a>mysql数据库基本操作-dml</h1><p>dml：data manipulation language，用来对数据库中表的数据记录进行增删改操作</p><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><pre><code class="mysql">给指定字段添加数据insert into 表名 (字段名1,字段名2) values (值1,值2,...);给全部字段添加数据insert into 表名 values ();批量添加数据insert into 表名 () values (),();insert into 表名 values (),();</code></pre><p>注意：</p><ul><li>字段顺序和值的顺序一一对应</li><li>字符串和日期型数据应该包含在引号中</li><li>数据大小在字段的规定范围中</li></ul><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><pre><code class="mysql">update 表名 set 字段名1=值1 [where 条件];</code></pre><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><pre><code class="mysql">delete from 表名 [where 条件];</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-ddl</title>
      <link href="/2023/08/25/mysql-ddl/"/>
      <url>/2023/08/25/mysql-ddl/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql数据库基本操作-ddl"><a href="#mysql数据库基本操作-ddl" class="headerlink" title="mysql数据库基本操作-ddl"></a>mysql数据库基本操作-ddl</h1><h2 id="对数据库的常用操作"><a href="#对数据库的常用操作" class="headerlink" title="对数据库的常用操作"></a>对数据库的常用操作</h2><table><thead><tr><th>功能</th><th>sql</th></tr></thead><tbody><tr><td>查看所有的数据库</td><td>show databases;</td></tr><tr><td>创建数据库</td><td>create database [if not exists] mydb [charset&#x3D;utf8];</td></tr><tr><td>切换数据库</td><td>use mydb;</td></tr><tr><td>删除数据库</td><td>drop database [if exists] mydb;</td></tr></tbody></table><h2 id="对表结构的常用操作"><a href="#对表结构的常用操作" class="headerlink" title="对表结构的常用操作"></a>对表结构的常用操作</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><pre><code class="mysql">create table 表名(    字段名1 类型[(宽度)] [约束条件] [comment &#39;字段说明&#39;],    字段名2 类型[(宽度)] [约束条件] [comment &#39;字段说明&#39;],    ...)[表的一些设置];</code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>常用</p><table><thead><tr><th>tinyint</th><th>1byte</th><th>(-128,127)</th><th>(0,255)</th></tr></thead><tbody><tr><td>smallint</td><td>2</td><td>(-32768,32767)</td><td>(0,65535)</td></tr><tr><td>mediumint</td><td>3</td><td>(-8388608,8388607)</td><td>(0,16777215)</td></tr><tr><td>int&#x2F;integer</td><td>4</td><td>(-2147483648,2147483647)</td><td>(0,4294967295)</td></tr><tr><td>bigint</td><td>8</td><td></td><td></td></tr><tr><td>float</td><td>4</td><td></td><td></td></tr><tr><td>double</td><td>8</td><td></td><td></td></tr><tr><td>decimal</td><td></td><td>依赖与M和D的值</td><td>依赖与M和D的值</td></tr><tr><td>vachar</td><td>0-65532</td><td>变长字符串</td><td></td></tr><tr><td>char</td><td>0-255</td><td>定长字符串</td><td></td></tr><tr><td>date（日期值）</td><td>3</td><td>1000-01-01至9999-12-31</td><td>YYYY-MM-DD</td></tr><tr><td>time（时间值或持续时间）</td><td>3</td><td>-838:59:59至838:59:59</td><td>HH:MM:SS</td></tr><tr><td>datetime</td><td>8</td><td></td><td>YYYY-MM-DD HH:MM:SS</td></tr></tbody></table><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p>添加字段</p><pre><code class="mysql">alter table 表名 add 字段名1 类型[(宽度)] [约束条件] [comment &#39;字段说明&#39;];</code></pre><p>修改数据类型</p><pre><code class="mysql">alter table 表名 modify 字段名 新数据类型（长度）;</code></pre><p>修改字段名和字段类型</p><pre><code class="mysql">alter table 表名 change 旧字段名 新字段名 类型（长度） [comment &#39;字段说明&#39;] [约束];</code></pre><p>删除字段</p><pre><code class="mysql">alter table 表名 drop 字段名;</code></pre><p>修改表名</p><pre><code class="mysql">alter table 表名 rename to 表名;</code></pre><p>删除表</p><pre><code class="mysql">drop table [if exists] 表名;</code></pre><p>删除指定表，并重新创建该表</p><pre><code class="mysql">truncate table 表名</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>constructTree</title>
      <link href="/2023/06/12/constructTree/"/>
      <url>/2023/06/12/constructTree/</url>
      
        <content type="html"><![CDATA[<h1 id="三种遍历方式构造二叉树的通解"><a href="#三种遍历方式构造二叉树的通解" class="headerlink" title="三种遍历方式构造二叉树的通解"></a>三种遍历方式构造二叉树的通解</h1><h2 id="不同之处一：寻找当前根节点"><a href="#不同之处一：寻找当前根节点" class="headerlink" title="不同之处一：寻找当前根节点"></a>不同之处一：寻找当前根节点</h2><ul><li><p>前+中</p><p>当前根节点为pre[pre_start]，找出它在中序中的位置，然后把左右子树分开。</p></li><li><p>中+后</p><p>当前根节点为post[post_end]，找出它在中序中的位置，然后把左右子树分开。</p></li><li><p>前+后</p><p>当前根节点为pre[pre_start]，并在他在后序中的位置为post_end；左子树的根节点为pre[pre_start+1]，因此只要找到他在后序中的位置就可以分开左右子树</p></li></ul><h2 id="不同之处二：左右遍历范围"><a href="#不同之处二：左右遍历范围" class="headerlink" title="不同之处二：左右遍历范围"></a>不同之处二：左右遍历范围</h2><ul><li>前+中<br>中序遍历中，我们知道 左子树：[inorder_start,index-1], 右子树：[index+1, inorder_end]<br>在前序遍历中，左子树起始位置为pre_start+1,左子树一共有(index-1 - inorder_start)个，因此左子树：[pre_start+1, pre_start+1 + (index-1 - inorder_start)]<br>右子树起始位置为左子树终止位置+1，终止位置为pre_end，因此右子树：[ pre_start+1 + (index-1 - inorder_start) + 1, pre_end]</li><li>中+后<br>中序遍历中，我们知道 左子树：[inorder_start,index-1], 右子树：[index+1, inorder_end]<br>在后序遍历中，左子树起始位置为post_start，左子树一共有(index-1 - inorder_start)个，因此左子树：[post_start, post_start + (index-1 - inorder_start)]<br>右子树的终止位置为post_end - 1,右子树一共有(inorder_end - (index+1))个,因此右子树:[post_end - 1 - (inorder_end - (index+1)), post_end - 1]</li><li>前+后<br>后序遍历中，我们知道 左子树：[post_start,index], 右子树：[index+1, post_end-1]<br>在前序遍历中，左子树起始位置为pre_start+1,左子树个数一共有(index - post_start)个，因此左子树：[pre_start+1, pre_start+1 + (index - post_start)]<br>右子树起始位置为左子树终止位置+1，终止位置为pre_end，因此右子树：[ pre_start+1 + (index - post_start) + 1, pre_end]</li></ul><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code class="java">//从前序和中序遍历序列构造二叉树class Solution &#123;    private Map&lt;Integer,Integer&gt; indexMap;    int rootIndex=0;    public TreeNode myBuildTree(int[] preorder,int[] inorder,int preorderLeft,int preorderRight)&#123;        if(preorderLeft&lt;=preorderRight)&#123;            int rootVal=preorder[rootIndex++];            TreeNode root=new TreeNode(rootVal);            root.left=myBuildTree(preorder,inorder,preorderLeft,indexMap.get(rootVal)-1);            root.right=myBuildTree(preorder,inorder,indexMap.get(rootVal)+1,preorderRight);            return root;        &#125;else&#123;            return null;        &#125;    &#125;    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;        int n=preorder.length;        indexMap=new HashMap&lt;&gt;();        for(int i=0;i&lt;n;i++)&#123;            indexMap.put(inorder[i],i);        &#125;        return myBuildTree(preorder,inorder,0,n-1);    &#125;&#125;//从中序和后序遍历序列构造二叉树class Solution &#123;    Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;();    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;        int n=inorder.length;        for(int i=0;i&lt;n;i++)&#123;            map.put(inorder[i],i);        &#125;        return myBuildTree(inorder,postorder,0,n-1,0,n-1);    &#125;    public TreeNode myBuildTree(int[] inorder,int[] postorder,int inorderLeft,int inorderRight,int postorderLeft,int postorderRight)&#123;        if (postorderLeft &gt; postorderRight) &#123;            return null;        &#125;        int postorderRoot = postorderRight;        // 在中序遍历中定位根节点        int inorderRoot = map.get(postorder[postorderRoot]);                // 先把根节点建立出来        TreeNode root = new TreeNode(postorder[postorderRoot]);        // 得到左子树中的节点数目        int size_left_subtree = inorderRoot - inorderLeft;                root.left = myBuildTree(inorder, postorder, inorderLeft,inorderRoot-1, postorderLeft, postorderLeft+size_left_subtree-1);                root.right = myBuildTree(inorder, postorder, inorderRoot+1, inorderRight, postorderLeft+size_left_subtree, postorderRight-1);        return root;    &#125;&#125;//从前序和后序遍历构造二叉树class Solution &#123;    Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;();    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) &#123;        int n=postorder.length;        for(int i=0;i&lt;n;i++)&#123;            map.put(postorder[i],i);        &#125;        return myBuildTree(preorder,postorder,0,n-1,0,n-1);    &#125;    public TreeNode myBuildTree(int[] preorder,int[] postorder,int preorderL,int preorderR,int postorderL,int postorderR)&#123;        if(preorderL&gt;postorderR)&#123;            return null;        &#125;        TreeNode root=new TreeNode(preorder[preorderL]);        int leftSize=map.get(preorder[preorderL+1])-postorderL+1;        root.left=myBuildTree(preorder,postorder,preorderL+1,preorderL+leftSize,postorderL,postorderL+leftSize-1);        root.right=myBuildTree(preorder,postorder,preorderL+leftSize+1,preorderR,postorderL+leftSize,postorderR-1);        return root;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> construct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm-class-loading-process</title>
      <link href="/2023/05/24/jvm-class-loading-process/"/>
      <url>/2023/05/24/jvm-class-loading-process/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="/..%5Cimages%5C68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f6a766d2f6c6966656379636c652d6f662d612d636c6173732e706e67" alt="img"></p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>上图中的加载-&gt;连接-&gt;初始化，连接过程又分为三步：验证-&gt;准备-&gt;解析</p><ul><li><p>加载</p><ol><li><p>通过类名获取此类的二进制字节流</p></li><li><p>将字节流代表的静态存储结构转换为方法区的运行时数据结构</p></li><li><p>在内存中生成一个代表该类的class对象，作为方法区这些数据的访问入口</p></li></ol></li></ul><p>每个java类都有一个引用指向加载它的ClassLoader。但是数组类不是通过ClassLoader创建的，而是JVM在需要的时候自动创建的，数组类通过getClassLoader()方法获取ClassLoader的时候和该数组的元素类型的ClassLoader是一致的。非数组类的加载阶段是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的loadClass()）。加载阶段和连接阶段的部分动作是交叉进行的，加载阶段尚未结束，连接阶段就有可能开始了。</p><pre><code class="java">class Class&lt;T&gt; &#123;  ...  private final ClassLoader classLoader;  @CallerSensitive  public ClassLoader getClassLoader() &#123;     //...  &#125;  ...&#125;</code></pre><h3 id="类加载器加载规则"><a href="#类加载器加载规则" class="headerlink" title="类加载器加载规则"></a>类加载器加载规则</h3><p>根据需要动态加载。对于已经加载的类会被加载在ClassLoader中。</p><pre><code class="java">public abstract class ClassLoader &#123;  ...  private final ClassLoader parent;  // 由这个类加载器加载的类。  private final Vector&lt;Class&lt;?&gt;&gt; classes = new Vector&lt;&gt;();  // 由VM调用，用此类加载器记录每个已加载类。  void addClass(Class&lt;?&gt; c) &#123;        classes.addElement(c);   &#125;  ...&#125;</code></pre><h3 id="类加载器总结"><a href="#类加载器总结" class="headerlink" title="类加载器总结"></a>类加载器总结</h3><p><img src="/..%5Cimages%5C68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f6a766d2f636c6173732d6c6f616465722d706172656e74732d64656c65676174696f6e2d6d6f64656c2e706e67" alt="img"></p><p>除了BootstrapClassLoader是JVM本身的一部分，其他所有的类加载器都是在JVM外部实现的，并且全部继承自ClassLoader抽象类。这与做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。</p><ul><li><p>连接</p><ol><li><p>验证</p><p>确保Class文件的字节流中包含的信息符合所有约束条件，保证信息被当作代码运行后不会危害虚拟机自身的安全。</p><p><img src="/..%5Cimages%5C68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f6a766d2f636c6173732d6c6f6164696e672d70726f636573732d766572696669636174696f6e2e706e67" alt="img"></p></li><li><p>准备</p><p>正式为类变量分配内存并设置类变量初始值的阶段</p></li><li><p>解析</p><p>虚拟机将常量池内的符号引用替换为直接引用的过程</p></li></ol></li><li><p>初始化</p><p>是执行初始化方法<clinit>()方法的过程，是类加载的最后一步，这一步JVM才开始真正执行类中定义的Java程序代码（字节码）</p><h2 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h2><p>卸载类即该类的Class对象被GC</p><p>三个条件：</p><ol><li>该类的而所有实例对象被GC，也就是是堆中不存在该类的实例对象</li><li>该类在任何地方被引用</li><li>该类的类加载器的实例被GC</li></ol><p>因此，在JVM的生命周期中，由jvm自带的类加载器加载的类是不会被卸载的，但是由我们自定义的类加载器加载的类是可能被卸载的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm-learn</title>
      <link href="/2023/05/23/jvm-learn/"/>
      <url>/2023/05/23/jvm-learn/</url>
      
        <content type="html"><![CDATA[<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><h2 id="运行数据区域"><a href="#运行数据区域" class="headerlink" title="运行数据区域"></a>运行数据区域</h2><p>JDK1.7</p><p><img src="/../images/image-20230523163329596.png" alt="image-20230523163329596"></p><p>JDK1.8</p><p><img src="/../images%5Cimage-20230523163752233.png" alt="image-20230523163752233"></p><h1 id="JVM回收"><a href="#JVM回收" class="headerlink" title="JVM回收"></a>JVM回收</h1><p>JDK1.7</p><p><img src="/../images%5Cjdk1.7%E5%A0%86%E7%BB%93%E6%9E%84.png" alt="image-20230523163752233"></p><ul><li>新生代</li><li>老生代</li><li>永久代</li></ul><p>JDK1.8</p><p><img src="/..%5Cimages%5Cimage-20230523164208008.png" alt="image-20230523164208008"></p><ul><li>新生代</li><li>老生代</li><li>元空间</li></ul><h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><h4 id="如果判断一个常量为废弃常量"><a href="#如果判断一个常量为废弃常量" class="headerlink" title="如果判断一个常量为废弃常量"></a>如果判断一个常量为废弃常量</h4><p>JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区，此时hotspot对方法区的实现为永久代</p><p>JDK1.7字符串常量池被从方法区拿到了堆中，这里没有提高运行时常量池，也就是说字符串常量池被单独拿到了堆，运行常量池剩下的东西还在方法区，也就是永久代</p><p>JDK1.8 hotspot移除永久代用元空间代替，这个时候字符串常量池还在堆中，运行时常量池还在方法区，但方法区的实现从永生代变为了元空间。</p><p>假设字符串常量池中存在字符“abc”，如果当前没有任何String对象引用该常量，就说明此常量是废弃常量，如果此时发生内存回收的话而且有必要的话，“abc”就会被清楚</p><h4 id="如果判断一个类是无用的类"><a href="#如果判断一个类是无用的类" class="headerlink" title="如果判断一个类是无用的类"></a>如果判断一个类是无用的类</h4><p>满足三个条件</p><ol><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例</li><li>加载该类的classLoader被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ol><p>如果满足上述条件虚拟机可以对类进行回收，但并不是像对象一样不使用了就必然被回收</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>debug-skill</title>
      <link href="/2023/05/12/debug-skill/"/>
      <url>/2023/05/12/debug-skill/</url>
      
        <content type="html"><![CDATA[<h1 id="idea中利用条件判断快速定位列表元素"><a href="#idea中利用条件判断快速定位列表元素" class="headerlink" title="idea中利用条件判断快速定位列表元素"></a>idea中利用条件判断快速定位列表元素</h1><p>例如在发布问题默认用户时，假设首先通过页面控制台得到question.id&#x3D;&#x3D;3</p><p>我们此时找到QuestionService中 list方法，</p><pre><code class="java">for (Question question : questions) &#123;            User user = userMapper.selectByPrimaryKey(question.getCreator());            QuestionDTO questionDTO = new QuestionDTO();            BeanUtils.copyProperties(question, questionDTO);            questionDTO.setUser(user);            questionDTOList.add(questionDTO);        &#125;</code></pre><p>在第二句中打上断点，并加入condition如下图</p><p><img src="/../images/image-20230512124224225.png" alt="image-20230512124224225"></p><p>即可直接在id为3时调试bug</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> idea </category>
          
          <category> debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debug </tag>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git-learning</title>
      <link href="/2023/05/10/git-learning/"/>
      <url>/2023/05/10/git-learning/</url>
      
        <content type="html"><![CDATA[<h1 id="git命令学习"><a href="#git命令学习" class="headerlink" title="git命令学习"></a>git命令学习</h1><p>初始化文件夹</p><pre><code class="shell">git init</code></pre><p>添加新文件</p><pre><code class="shell">git add .git add filenamegit add -am</code></pre><p><code>git commit -am</code> 的作用是将所有已经被 Git 管理的文件添加到暂存区并提交这些变更，并且可以通过 <code>-m</code> 参数指定提交消息。需要注意的是，如果有新文件或未被 Git 管理的文件需要添加到仓库中，还需要使用 <code>git add</code> 命令将它们添加到暂存区中。</p><p>提交版本</p><pre><code class="shell">git commit -m &quot;说明&quot;</code></pre><p>在本地的git仓库添加远程仓库</p><pre><code class="shell">git remote add origin [url]</code></pre><p>发布版本</p><pre><code class="shell">git push origin mastergit push --set-upstream origin [branch]</code></pre><p>origin其实就是远程仓库地址，master就是分支。在.git文件夹中的config都可以修改。</p><p>拉去到本地仓库</p><ul><li><p>默认合并</p><pre><code class="shell">git pull</code></pre></li><li><p>非默认</p><pre><code class="shell">git pull [url]</code></pre></li><li><p>拉取所有分支</p></li></ul><pre><code class="shell">git fetch</code></pre><p>创建分支</p><pre><code class="shell">git branch (name)</code></pre><p>切换分支</p><pre><code class="shell">git checkout (name)</code></pre><p>创建分支并切换到该分支</p><pre><code class="shell">git checkout -b (name)</code></pre><p>删除分支</p><pre><code class="shell">git branch -d (name)</code></pre><p>合并分支</p><pre><code class="shell">git merge (name)</code></pre><p>将(name)分支合并到当前所在分支，此处通常当分支&#x2F;测试分支有了独立内容，希望合并的时候，也就是测试正确的时候合并到当前分支。合并完后一般删除分支</p><p>撤回到某个版本（在还没push之前）</p><pre><code class="shell">git reset HEAD</code></pre><p>合并到上一次commit中</p><pre><code class="shell">git add .git commit --amend</code></pre><h2 id="git-error"><a href="#git-error" class="headerlink" title="git error"></a>git error</h2><ul><li><p>ssh: connect to host github.com port 22: Connection timed out fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists.</p><p>解决方法：</p><ol><li><p>修改.git文件中的config文件将origin的url换为http地址</p></li><li><p>修改端口号</p><pre><code class="shell">cd ~/.sshvim congfig</code></pre></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis:MapperXML文件报错(Unable to resolve table &#39;limit&#39;)</title>
      <link href="/2023/05/10/MybatisMapperXML%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99/"/>
      <url>/2023/05/10/MybatisMapperXML%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis-MapperXML文件报错-Unable-to-resolve-table-‘limit’"><a href="#Mybatis-MapperXML文件报错-Unable-to-resolve-table-‘limit’" class="headerlink" title="Mybatis:MapperXML文件报错(Unable to resolve table ‘limit’)"></a>Mybatis:MapperXML文件报错(Unable to resolve table ‘limit’)</h1><p>在使用<where><if></if></where>时报错</p><pre><code class="javascript">&lt;select id=&quot;selectBySearch&quot; parameterType=&quot;life.mhe.community.dto.QuestionQueryDTO&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select * from question        &lt;where&gt;            &lt;if test=&quot;search!=null&quot;&gt;                 title regexp #&#123;search&#125;            &lt;/if&gt;        &lt;/where&gt;        order by gmt_create desc limit #&#123;page&#125;,#&#123;size&#125;    &lt;/select&gt;</code></pre><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>起初将where和if交换位置依旧报错</p><p>类似问题：</p><p>[]: <a href="https://stackoverflow.com/questions/60575770/">https://stackoverflow.com/questions/60575770/</a></p><p>最终将标签<where>改为where关键字解决</p><pre><code class="javascript">where            &lt;if test=&quot;search!=null&quot;&gt;                 title regexp #&#123;search&#125;            &lt;/if&gt;        order by gmt_create desc limit #&#123;page&#125;,#&#123;size&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-最长回文子串</title>
      <link href="/2023/05/10/leetcode-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2023/05/10/leetcode-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>解法：动态规划</p><pre><code class="java">public class Solution &#123;    public String longestPalindrome(String s) &#123;        int len = s.length();        if (len &lt; 2) &#123;            return s;        &#125;        int maxLen = 1;        int begin = 0;        // dp[i][j] 表示 s[i..j] 是否是回文串        boolean[][] dp = new boolean[len][len];        // 初始化：所有长度为 1 的子串都是回文串        for (int i = 0; i &lt; len; i++) &#123;            dp[i][i] = true;        &#125;        char[] charArray = s.toCharArray();        // 递推开始        // 先枚举子串长度        for (int L = 2; L &lt;= len; L++) &#123;            // 枚举左边界，左边界的上限设置可以宽松一些            for (int i = 0; i &lt; len; i++) &#123;                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得                int j = L + i - 1;                // 如果右边界越界，就可以退出当前循环                if (j &gt;= len) &#123;                    break;                &#125;                if (charArray[i] != charArray[j]) &#123;                    dp[i][j] = false;                &#125; else &#123;                    if (j - i &lt; 3) &#123;                        dp[i][j] = true;                    &#125; else &#123;                        dp[i][j] = dp[i + 1][j - 1];                    &#125;                &#125;                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置                if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLen) &#123;                    maxLen = j - i + 1;                    begin = i;                &#125;            &#125;        &#125;        return s.substring(begin, begin + maxLen);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-use</title>
      <link href="/2023/05/09/hexo-use/"/>
      <url>/2023/05/09/hexo-use/</url>
      
        <content type="html"><![CDATA[<h2 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h2><p>hexo new &lt;&gt;</p><p>git<br>git add .<br>git commit -m “”<br>git push origin public</p><p>发布网站并推送静态文件到master分支<br>hexo g -d</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

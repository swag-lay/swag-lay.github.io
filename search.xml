<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>sql_lock</title>
      <link href="/2023/09/05/sql-lock/"/>
      <url>/2023/09/05/sql-lock/</url>
      
        <content type="html"><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>对整个数据库加锁，之后整个实例处于只读状态，后续的dml的写语句，ddl语句，已经更新操作的事务提交语句都将被阻塞。</p><p>典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p><p>特点：</p><p>​如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</p><p>​如果从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志，会导致主从延迟。</p><p>在innodb引擎中，我们可以在备份时加上参数–single-transaction参数来完成不加锁的一致性数据备份</p><pre><code class="sql">mysqldump --single-transaction -uroot -p123456 itcase&gt;itcast.sql</code></pre><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在mylsam，innodb，bdb等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><p>表锁</p><p>​表共享读锁（read lock）</p><p>​表独占写锁 （write lock）</p><p>元数据锁（mdl）</p><p>系统 自动控制，无需显式使用。主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免dml和ddl冲突，保证读写的正确性。</p><p>在mysql5.5中引入了mdl，对一张表进行增删改查的时候，加mdl读锁（共享）；当对表结构进行变更操作的时候，加mdl写锁（排他）。</p><p>意向锁</p><p>​意向共享锁（IS）：由语句select…lock in share mode添加</p><p>​意向排他锁（IX）：由insert，update，delete，select…for update添加</p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在innodb中。</p><p>innodb的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p><p>​行锁：锁住单行记录的锁，防止其他事务对此行进行update和delete，在rc，rr隔离级别下都支持</p><p>​共享锁（S），排他锁（X）</p><p>​间隙锁：锁定索引记录间隙（不包含改记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在rr隔离级别下都支持。vb  </p><p>​临键锁：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙gap，在rr隔离级别下支持。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql_trigger</title>
      <link href="/2023/09/05/sql-trigger/"/>
      <url>/2023/09/05/sql-trigger/</url>
      
        <content type="html"><![CDATA[<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>触发器是与表相关的数据库对象，指在insert&#x2F;update&#x2F;delete之前或之后，触发并执行触发器中定义的sql语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。</p><p>使用别名old和new来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p><p>创建</p><pre><code class="sql">create trigger ...before/after insert/update/deleteon ... for each row begin     trigger_stmt;end;</code></pre><p>查看</p><pre><code class="sql">show triggers;</code></pre><p>删除</p><pre><code class="sql">drop trigger [schema_name]trigger_name;--如果没有指定schema_name，默认为当前数据库</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql_stored</title>
      <link href="/2023/09/04/sql-stored/"/>
      <url>/2023/09/04/sql-stored/</url>
      
        <content type="html"><![CDATA[<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>介绍：事先经过编译并存储在数据库中的一段sql语句的集合，调用存储过程并可以简化应用开发任意的许多工作。减少数据在数据库和应用数据库之间的传输。</p><p>数据库sql语言层面的代码封装和重用。</p><p>特点：</p><p>封装，复用。</p><p>可以接收参数，也可以返回数据</p><p>减少网络交互，效率提升</p><p>创建：</p><pre><code class="sql">create procedure 存储过程名称([参数列表])begin    --sql语句end;</code></pre><p>调用：</p><pre><code class="sql">call 名称([参数]);</code></pre><p>查看</p><pre><code class="sql">select * from information_schema.routines_schema=&#39;xxx&#39;;--查询指定数据库的存储过程及状态信息show create procedure 存储过程名称;--查询某个存储过程的定义</code></pre><p>删除</p><pre><code class="sql">drop procedure [if exists] 存储过程名称;</code></pre><p>注意：在命令行中，执行创建存储过程的sql时，需要通过关键字delimiter指定sql语句的结束符</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>系统变量是mysql服务器提供的，不是用户定义的，属于服务器层面。分为全局变量（global），会话变量（session）。</p><p>查看系统变量</p><pre><code class="sql">show [session|global] variables; --查看所有系统变量show [session|global] variables like &#39;...&#39;; --可以通过like模糊匹配方式查找变量select @@[session|global]系统变量名; --查看指定变量的值</code></pre><p>设置系统变量</p><pre><code class="mysql">set [session|global] 系统变量名=值;set @@[session|global]系统变量名=值;</code></pre><p>注意：如果没有指定session&#x2F;global，默认是session，会话变量</p><p>mysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在&#x2F;etc&#x2F;my.cnf中配置</p><p>用户定义变量</p><p>是用户根据需要自己定义的变量，用户变量不用提取声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。</p><p>赋值：</p><pre><code class="sql">set @var_name=expr [,@var_name=expr]...;set @var_name:=expr [,@var_name:=expr]...;select @var_name:=expr [,@var_name:=expr]...;select 字段名 into @var_name from 表名;</code></pre><p>使用</p><pre><code class="sql">select @var_name;</code></pre><p>注意：用户定义的变量无需对其进行声明或初始化，只不过获取到的值为null。</p><p>局部变量</p><p>是根据需要定义的在局部生效的变量，访问之前，需要declare声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的begin…end块。</p><p>声明</p><pre><code class="sql">declare 变量名 变量类型[...];</code></pre><p>赋值</p><pre><code class="sql">set 变量=值;set 变量名:=值;select 字段名 into 变量名 from 表名...;</code></pre><p>if</p><pre><code class="mysql">if ... then     ...elseif ... then     ...else     ...end if;</code></pre><p>参数</p><table><thead><tr><th>类型</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>in</td><td>该类参数作为输入，也就是需要调用时传入值</td><td>默认</td></tr><tr><td>out</td><td>该类参数作为输出，作为返回值</td><td></td></tr><tr><td>inout</td><td>即可以作为输入参数，也可以作为输出参数</td><td></td></tr></tbody></table><pre><code class="sql">create procedure 存储过程名称([in/out/inout 参数名 参数类型])beginend;</code></pre><p>case</p><pre><code class="mysql">case ...    when ... then ...    ..    [else ...]end case;</code></pre><pre><code class="mysql">case     when ... then ...    ..    [else ...]end case;</code></pre><p>while</p><pre><code class="mysql">while ... do    ...end while;</code></pre><p>repeat</p><pre><code class="mysql">repeat     ..    until ...end repeat;</code></pre><p>loop</p><pre><code class="mysql">[begin_lable:] loop    ...end loop[end_label];leave label;--退出指定标记的循环体iterate label;--直接进入下一次循环</code></pre><p>游标：</p><p>用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。</p><p>声明</p><pre><code class="mysql">declare ... cursor for ...;</code></pre><p>打开</p><pre><code class="mysql">open ...;</code></pre><p>获取游标记录</p><pre><code class="mysql">fetch ... into 变量[,变量];</code></pre><p>关闭游标</p><pre><code class="mysql">close ...;</code></pre><p>条件处理程序</p><pre><code class="sql">declare handler_action  handler for condition_value[,condition_value]... statement;handler_action    continue:继续执行当前程序    exit:终止执行当前程序condition_value    sqlstate sqlstate_value:状态码，如02000    sqlwarning:所有以01开头的sqlstate代码的简写    not found:所有以02开头的sqlstate代码的简写    sqlexception:所有没有被sqlwarning或not found捕获的sqlstate代码的简写</code></pre><h1 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h1><p>存储函数是有返回值的存储过程，存储函数的参数只能是in类型</p><pre><code class="mysql">create function 存储函数名称([参数列表])returns type [characteristic ...]begin    ...    return ...;end;</code></pre><p>characteristic说明</p><p>​deterministic：相同的输入参数总数产生相同的结果</p><p>​no sql：不包含sql语句</p><p>​reads sql data：包含读取数据的语句，但不包含写入数据的语句</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql_view</title>
      <link href="/2023/09/01/sql-view/"/>
      <url>/2023/09/01/sql-view/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL视图"><a href="#SQL视图" class="headerlink" title="SQL视图"></a>SQL视图</h1><p>介绍：视图是一种虚拟存储的表，视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗来讲，视图只保存了查询的sql逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在了创建这条sql查询语句上。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><pre><code class="mysql">create [or replace] view 视图名称[(列名列表)] as select语句 [with[cascaded | local] check option]</code></pre><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><pre><code class="mysql">查看创建视图语句：show create view ...;查看视图数据：select * from ...;#表怎么查视图怎么查</code></pre><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><pre><code class="mysql">create [or replace] view 视图名称[(列名列表)] as select语句 [with[cascaded | local] check option]alter view 视图名称[(列名列表)] as select语句 [with[cascaded | local] check option]</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><pre><code class="mysql">drop view [if exists] 视图名称[(列名列表)]</code></pre><h2 id="视图的检查选项"><a href="#视图的检查选项" class="headerlink" title="视图的检查选项"></a>视图的检查选项</h2><p>使用with check option子句创建视图时，mysql会通过视图检查正在修改的每一行，例如插入，更新，删除，以使其符合视图的定义。mysql允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项：cascaded和local，默认值cascaded。</p><p>local 不会把上一个视图也加上一致性检查</p><h2 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h2><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图中包含以下任何一项，则视图不可更新</p><p>​聚合函数或窗口函数</p><p>​distinct</p><p>​group by</p><p>​having</p><p>​union或者union all</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sql_optimize</title>
      <link href="/2023/09/01/sql-optimize/"/>
      <url>/2023/09/01/sql-optimize/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>insert插入：批量插入，手动提交事务，主键顺序插入</p><p>大批量插入数据：使用load指令进行插入</p><pre><code class="mysql">mysql --local-infile -u root -pset global local_infile=1;load data local infile &#39;/root/sql1.log&#39; into table ... fields terminated by &#39;,&#39; lines terminated by &#39;\n&#39;;</code></pre><h2 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h2><p>主键乱序插入会发生页分裂 页合并</p><p>主键设计原则</p><p>​尽量降低主键的长度</p><p>​插入数据时，尽量选择顺序插入，选择使用auto_increment自增主键</p><p>​尽量不要使用uuid做主键或者是其他自然主键，如身份证号</p><p>​业务操作时，避免对主键的修改</p><h2 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h2><p>using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都是filesort排序</p><p>using index：通过有序索引顺序扫描直接返回有序数据，这种情况称为using index，不需要额外排序，操作效率高。</p><p>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法制</p><p>尽量使用覆盖索引</p><p>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（asc&#x2F;desc）</p><p>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size（默认256k）</p><h2 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h2><p>通过索引</p><p>最左前缀法制</p><h2 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h2><p>优化思路：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p><h2 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h2><p>优化思路：自己计数</p><p>效率排序：count(*)约等于count(1)&gt;count(主键id)&gt;count(字段)</p><h2 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h2><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则就会从行锁升级为表锁</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql-index</title>
      <link href="/2023/08/29/mysql-index/"/>
      <url>/2023/08/29/mysql-index/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql-索引"><a href="#mysql-索引" class="headerlink" title="mysql-索引"></a>mysql-索引</h1><p>索引是帮助mysql<strong>高效获取数据的数据结构（有序）</strong>。这些数据结构以某种方式引用（指向）数据，这也就可以在这些数据结构上是实现高级查找算法，这种数据结构就是索引。</p><p>优势：提高数据检索的效率，降低数据的io成本，降低数据库排序的成本，降低cpu的消耗。</p><p>缺点：索引列需要空间，降低了更新表的速度。</p><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>相对于B树区别：所有的数据都会出现在叶子节点，叶子节点形成一个单向链表</p><p>Mysql索引结构对经典B+树进行了优化，在原B+树基础上，增加了一个指向相邻叶子节点的链表指针，形成了带有顺序指针的B+树，提高区间访问的效率。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>用的链地址法处理冲突</p><p>特点：</p><p>​hash索引只能用于对等比较（&#x3D;，in），不支持范围查询（between，&gt;，&lt;，…）</p><p>​无法利用索引完成排序操作</p><p>​查询效率高，通常只需要以此检索就可以了，效率通常高于b+树</p><p>mysql中，支持hash索引的是Memory引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+树索引在指定条件下自动构建的。</p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>primary</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>unique</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>fulltext</td></tr></tbody></table><p>在innodb中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引（clustered index）</td><td>将数据存储和索引放到了一块，索引结构中的叶子节点保持了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>二级索引（secondary index）</td><td>将数据和索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>聚集索引选取规则：</p><p>​以下顺序：主键索引-&gt;唯一索引-&gt;自动生成一个rowid作为隐藏的聚集索引。</p><h2 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h2><p>创建索引</p><pre><code class="mysql">create [unique|fulltext] index index_name on table_name (index_col_name,...);# 前缀索引 n表示前多少个位置cerate index idx_xxxx on table_name(column(n))可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的select count(distinct xxx)/count(*) from xxx;select count(distinct substring(xxx,1,n))/count(*) from xxx;</code></pre><p>查看索引</p><pre><code class="mysql">show index from table_name;</code></pre><p>删除索引</p><pre><code class="mysql">drop index index_name on table_name;</code></pre><h2 id="sql性能分析"><a href="#sql性能分析" class="headerlink" title="sql性能分析"></a>sql性能分析</h2><p>sql执行频率：mysql客户端连接成功后，通过show [session|global] status命令可以提供服务器状态信息。可以查看当前数据库的insert，update，delete，select的访问频次</p><pre><code class="mysql">show global status like &#39;Com____&#39;;</code></pre><p>慢查询日志</p><p>profile详情</p><pre><code class="mysql"># 查看每一条sql的耗时基本情况show profiles;# 查看指定query_id的sql语句每个阶段的耗时情况show profile for query query_id;# 查看指定query_id的sql语句cpu的使用情况show profile cpu for query_id;</code></pre><p>explain执行计划</p><p>explain或者desc命令获取mysql如果执行select语句的信息，包括在select语句执行过程中表如果连接和连接的顺序</p><pre><code class="mysql"># 直接在select语句之前加上关键字explain/descexplain ...</code></pre><h2 id="索引使用规则"><a href="#索引使用规则" class="headerlink" title="索引使用规则"></a>索引使用规则</h2><p>1.争对数据量较大，查询比较频繁的表建立索引</p><p>2.针对常作为where，order by，group by操作的字段建立索引</p><p>3.尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</p><p>4.如果是字符串类型，字符较长，针对字段的特点，建立前缀索引</p><p>5.尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高效率</p><p>6.控制索引的数量</p><p>7.如果索引列不能存储null值，请在创建表时使用not null约束它，当优化器知道每列是否包含null值时，它可以更好的确定哪个索引更有效的用于查询</p><p>最左前缀法制</p><p>如果索引了多列（联合索引），要遵守最左前缀法制，查询从索引的最左列开始（放的位置没有影响，只要存在），并且不跳过索引中的列。</p><p>如果跳过某一列，索引将部分失效（<strong>后面的字段索引失效</strong>）</p><p>范围查询</p><p>联合索引中，出现范围查询（&gt;，&lt;），范围查询右侧的列索引失效</p><p>索引列运算</p><p>不要在索引列上进行运算操作，索引将失效</p><p>字符串不加引号</p><p>字符串类型字段使用时，不加引号，索引将失效</p><p>模糊查询</p><p>如果仅仅是尾部模糊匹配，索引不会失效，如果是头部模糊匹配，索引失效。如果把查询列换为索引与之对应的列，头部模糊匹配就会解决，也就是使用覆盖索引</p><p>or连接的条件</p><p>用or分隔开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到</p><p>数据分布影响</p><p>如果mysql评估使用索引比全表更慢，则不会使用索引</p><p>sql提示</p><p>use index：使用某索引</p><p>ignore index：忽略某索引</p><p>force index：强制执行某索引</p><p>覆盖索引</p><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到），减少select *</p><p>using index condition：查找使用了索引，但是需要回表查询数据</p><p>using where，using index：查找使用了索引，但是需要的数据都在索引列中能够找到，所以不需要回表查询数据</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql-storage-engine</title>
      <link href="/2023/08/29/mysql-engine/"/>
      <url>/2023/08/29/mysql-engine/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql-存储引擎"><a href="#mysql-存储引擎" class="headerlink" title="mysql-存储引擎"></a>mysql-存储引擎</h1><h2 id="mysql体系结构"><a href="#mysql体系结构" class="headerlink" title="mysql体系结构"></a>mysql体系结构</h2><p><img src="/..%5Cimages%5Cimage-mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="image-20230829093941681"></p><p>连接层，服务层，引擎层，存储层</p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎是存储数据，建立索引，更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎可以被称为表类型。</p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>兼顾高可靠性和高性能的通用存储引擎，在mysql5.5之后，InnoDB是默认的存储引擎。</p><p>特点：</p><p>DML操作遵循ACID模型，支持<strong>事务</strong>；</p><p><strong>行级锁</strong>，提高并发访问性能；</p><p>支持外键foreign key约束，保证数据的完整性和正确性。</p><p>文件：</p><p>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm，sdi），索引和数据。</p><p>参数：innodb_file_per_table</p><h3 id="MyISM"><a href="#MyISM" class="headerlink" title="MyISM"></a>MyISM</h3><p>mysql早期的默认存储引擎。</p><p>特点：</p><p>不支持事务，不支持外键</p><p>支持表锁，不支持行锁</p><p>访问速度快</p><p>文件：</p><p>xxx.sdi：存储表结构信息</p><p>xxx.MYD：存储数据<br>xxx.MYI：存储索引</p><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>表数据存储在内存中，由于受到硬件问题，或断电问题的影响，只能将这些表作为临时表或缓存使用</p><p>特点：</p><p>内存存放</p><p>hash索引（默认）</p><p>文件：</p><p>xxx.sdi：存储表结构信息</p><p><img src="/..%5Cimages%5Cimage-%E5%BC%95%E6%93%8E%E7%89%B9%E7%82%B9.png" alt="image-20230829100341545"></p><h2 id="InnoDB-1"><a href="#InnoDB-1" class="headerlink" title="InnoDB"></a>InnoDB</h2><p><img src="/..%5Cimages%5Cinnodb.png" alt="image-20230906102612387"></p><p>表空间</p><p>ibd文件，一个mysql实例可以对应多个表空间，用于存储记录，索引等数据</p><p>段</p><p>分为数据段，索引段，回滚段，innodb是索引组织表，数据段就是b+树的叶子节点，索引段为b+树的非叶子节点。</p><p>区</p><p>表空间的单元结构，每个区的大小为1M。默认情况下，innodb存储引擎页大小为16k，即一个区中一共有64个连续的页。</p><p>页</p><p>innodb存储引擎磁盘管理的最小单元，每个页的大小默认为16kb，为了保证页的连续性，innodb存储引擎每次从磁盘申请4-5个区。</p><p>行</p><p>innodb存储引擎数据是按行进行存放的。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="/..%5Cimages%5Cinnodb%E6%9E%B6%E6%9E%84.png" alt="image-20230906103426248"></p><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p><img src="F:\swag-lay.github.io\source\images\innodb后台线程.png" alt="image-20230906133932389"></p><p>master thread</p><p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中，保持数据的一致性，还包括脏页的刷新，合并插入缓存，undo页的回收</p><p>io thread</p><p>大量使用了aio来处理io请求，这样可以极大地提高数据库的性能，而io thread负责这些io的回调</p><table><thead><tr><th>线程类型</th><th>默认个数</th><th>职责</th></tr></thead><tbody><tr><td>read thread</td><td>4</td><td>负责读操作</td></tr><tr><td>write thread</td><td>4</td><td>负责写操作</td></tr><tr><td>log thread</td><td>1</td><td>负责将日志缓冲区刷新到磁盘</td></tr><tr><td>insert buffer thread</td><td>1</td><td>负责将写缓冲区内容刷新到磁盘</td></tr></tbody></table><p>purge thread</p><p>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。</p><p>page cleaner thread</p><p>协助master thread刷新脏页到磁盘的线程，他可以减轻master thread的工作压力，减少阻塞</p><h3 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h3><p>不可分割的工作单位，把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>acid特性</p><p>原子性，一致性，持久性是由redo log，undo log决定的。</p><p>隔离性是由锁，mvcc决定的。</p><p>redo log：重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。改日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到改日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p><p>undo log：回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚和mvcc（多版本并发控制）</p><p>undo log和redo log记录物理日志不一样，它是逻辑日志。</p><p>undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于mvcc</p><p>undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍rollback segment回滚段中，内部包含1024个undo log segment</p><p>当insert的时候,产生的undo log日志只在回滚时需要,在事务提交后,可被立即删除.</p><p>而update,delete的时候,产生的undo log日志不仅在回滚时需要,在快照时也需要,不会立即被删除</p><p>undo log版本链:不同事务或相同事务对同一条记录进行修改,会导致该记录的undolog生成一条记录版本链表,链表的头部是最新的旧记录,链表尾部是最早的旧记录.</p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select…lock in share mode(共享锁)，select…for update,update,insert,delete(排他锁)都是一种当前读</p><h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读</p><p>read committed：每次select，都生成一个快照读</p><p>repeatable read：开启事务后第一个select语句才是快照读的地方</p><p>serializable：快照读会退化为当前读</p><h4 id="mvcc"><a href="#mvcc" class="headerlink" title="mvcc"></a>mvcc</h4><p>多版本并发控制.指维护一个数据的多个版本,使得读写操作没有冲突,快照读为mysql实现mvcc提供了一个非阻塞读功能.mvcc的具体实现,需要依赖于数据库记录中的三个隐式字段,undo log日志,readview.</p><p>三个隐式字段</p><table><thead><tr><th>隐藏字段</th><th>含义</th></tr></thead><tbody><tr><td>db_trx_id</td><td>最近修改事务id,记录插入这条记录或最后一次修改该记录的事务ID</td></tr><tr><td>db_roll_ptr</td><td>回滚指针,指向这条记录的上一个版本,用于配合undo log,指向上一个版本</td></tr><tr><td>db_row_id</td><td>隐藏主键,如果表结构没有指定主键,将会生成该隐藏字段</td></tr></tbody></table><p>readview</p><p>readview是快照读sql执行时mvcc提供数据的依据,记录并维护系统当前活跃的事务(未提交的)id.</p><p>readview中包含四个核心字段</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务id集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务id</td></tr><tr><td>max_trx_id</td><td>预分配事务id,当前最大事务id+1(因为事务id是自增的)</td></tr><tr><td>creator_trx_id</td><td>readview创建者的事务id</td></tr></tbody></table><p>不同的隔离级别,生成readview的时机不同</p><p>read committed:在事务中每一次执行快照时生成readview</p><p>repeatable read:仅在事务中第一次执行快照读时生成readview,后续复用readview</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>transaction_sql</title>
      <link href="/2023/08/28/transaction-sql/"/>
      <url>/2023/08/28/transaction-sql/</url>
      
        <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><h2 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h2><p>查看&#x2F;设置事务提交方式</p><pre><code class="mysql">select @@autocommit;set @@autocommit=0;#设置为手动改提交</code></pre><p>提交事务</p><pre><code class="mysql">commit;</code></pre><p>回滚事务</p><pre><code class="mysql">rollback；</code></pre><p>开启事务</p><pre><code class="mysql">start transaction 或 begin;</code></pre><h2 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h2><p>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</p><p>一致性（Consistency）：事务完成时，必须使所有的数据都保存一致状态。</p><p>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下允许。</p><p>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p><h2 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h2><p>脏读：一个事务读到另一个事务还没有提交的数据</p><p>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称为不可重复读</p><p>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了幻读</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>repeatable read（默认）</td><td>×</td><td>×</td><td>√</td></tr><tr><td>serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><pre><code class="mysql">-- 查看事务隔离级别select @@transaction_isolation;-- 设置事务隔离级别set [session|global] transaction isolation level &#123;read uncommitted | read committed | repeatabel read | serializable&#125;</code></pre><p>事务隔离级别越高，数据越安全，但安全越低。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>select_tables</title>
      <link href="/2023/08/28/select-tables/"/>
      <url>/2023/08/28/select-tables/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql多表查询"><a href="#mysql多表查询" class="headerlink" title="mysql多表查询"></a>mysql多表查询</h1><p>概述：各个表结构之间存在着多种联系，基本上分为三种：</p><p>一对多（多对一）：</p><p>​在多的一方建立外键，指向一的一方的主键（比如部门和员工的关系）</p><p>多对多</p><p>​建立第三种中间表，中间表至少包含两个外键，分别关联两方主键（例如学生和课程的关系）</p><p>一对一</p><p>​多用于单边拆分，将一张表的基础字段放在一张表中，其他详细字段放在另一张表中，以提升操作效率</p><p>​在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（unique）</p><h2 id="多表查询分类"><a href="#多表查询分类" class="headerlink" title="多表查询分类"></a>多表查询分类</h2><h3 id="连接分类"><a href="#连接分类" class="headerlink" title="连接分类"></a>连接分类</h3><h4 id="内连接："><a href="#内连接：" class="headerlink" title="内连接："></a>内连接：</h4><p>相当于查询A，B交集部分数据</p><p>隐式内连接</p><pre><code class="mysql">select .. from .. where 条件...;</code></pre><p>显式内连接</p><pre><code>select .. from 表1 [inner] join 表2 on 连接条件;</code></pre><h4 id="外连接："><a href="#外连接：" class="headerlink" title="外连接："></a>外连接：</h4><p>左外连接：查询左表所有数据，以及两张表交集部分数据</p><pre><code class="mysql">select .. from 表1 left [outer] join 表2 on .. #相当于查询表1（左表）的所有数据 包含 表1和表2交集部分的数据</code></pre><p>右外连接：查询右表所有数据，以及两张表交集部分数据</p><pre><code class="mysql">select .. from .. right [outer] join .. on .. #相当于查询表2（右表）的所有数据 包含 表1和表2交集部分的数据</code></pre><h4 id="自连接："><a href="#自连接：" class="headerlink" title="自连接："></a>自连接：</h4><p>当前表与自身的连接查询，自连接必须使用表别名。</p><p>自连接可以用内连接和外连接。</p><pre><code class="mysql">select .. from 表a 别名a join 表a 别名b on 条件 ..;</code></pre><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>sql语句中嵌套select语句，称为嵌套查询，又称子查询</p><pre><code class="mysql">select * from t1 where column1=(select column1 from t2);</code></pre><p>子查询外部的语句可以是insert&#x2F;update&#x2F;delete&#x2F;select中的任意一个</p><p>根据子查询结果不同，分为：</p><p>标量子查询（子查询结果为单个值）</p><p>列子查询（子查询结果为一列）</p><p>​常用操作符：in，not in，any，some ，all</p><p>行子查询（子查询结果为一行）</p><p>​常用操作符：&#x3D;，&lt;&gt;，in，not in</p><p>表子查询（子查询结果为多行多列）</p><p>​常用操作符：in</p><p>根据子查询位置，分为：where之后，from之后，select之后</p><h2 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h2><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集</p><p>union all会把所有的查询直接联合，union会去重</p><pre><code class="mysql">select .. from ..union [all]select .. from ..;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>constraint</title>
      <link href="/2023/08/28/constraint/"/>
      <url>/2023/08/28/constraint/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql约束"><a href="#mysql约束" class="headerlink" title="mysql约束"></a>mysql约束</h1><p>约束是作用于表中字段上的规则，用于限制存储在表中的数据。为了保证数据库中数据的正确，有效性和完整性。</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>not null</td></tr><tr><td>唯一约束</td><td>唯一，不重复的</td><td>unique</td></tr><tr><td>主键约束</td><td>唯一标识，要求非空且唯一</td><td>primary key</td></tr><tr><td>默认</td><td></td><td>default</td></tr><tr><td>检查约束（8.0.16之后）</td><td>保证字段值满足某一个条件</td><td>check</td></tr><tr><td>外键约束</td><td>用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td><td>foreign key</td></tr></tbody></table><p>注意：约束是作用于表中字段上的，可以在创建表&#x2F;修改表的时候添加约束。</p><p>外键约束：</p><pre><code class="mysql">create table 表名(    字段名 数据类型,    ...    [constraint] [外键名称] foreign key(外键字段名) references 主表(主表列名));-- 添加外键alter table 表名 add constraint 外键名称 foreign key(外键字段名) references 主表(主表列名);-- 删除外键alter table 表名 drop foreign key 外键名称;</code></pre><p>删除&#x2F;更新行为</p><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>no action</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。（与restrict一致）</td></tr><tr><td>restrict</td><td>。。。 ，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。（与no action一致）</td></tr><tr><td>cascade</td><td>。。。，首先检查该记录是否有对应外键，如果有，则也删除&#x2F;更新外键在子表中的记录</td></tr><tr><td>set null</td><td>。。。，首先检查该记录是否有对应外键，如果有则设置子表中该外键为null（这就要求该外键允许曲null）</td></tr><tr><td>set default</td><td>父表有变更时，子表将外键列设置为一个默认的值（Innodb不支持）</td></tr></tbody></table><pre><code class="mysql">alter table 表名 add constraint 外键名称 foreign key (外键名称) references 主表名（主表字段名） on update cascade on delete cascade;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-funs</title>
      <link href="/2023/08/28/mysql-funs/"/>
      <url>/2023/08/28/mysql-funs/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql中的函数"><a href="#mysql中的函数" class="headerlink" title="mysql中的函数"></a>mysql中的函数</h1><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><pre><code class="mysql">concat(s1,s2,...,sn) #字符串拼接lower(str) 将str转换为小写upper(str) 将str转换为大写lpad(str,n,pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度rpad(str,n,pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度trim(str) 去掉字符串头部和尾部的空格substring(str,start,len) 返回从字符串str从start位置起len个长度的字符串</code></pre><h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><pre><code class="mysql">ceil(x) 向上取整floor(x) 向下取整mod(x,y) 返回x/y的模rand() 返回0-1内的随机数round(x,y) 求参数x的四舍五入的值，保留y位小数</code></pre><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><pre><code class="mysql">curdate() 当前日期curtime() 当前时间now() 返回当前日期和时间year(date) 获取指定date的年份month(date) 获取指定date的月份day(date) 获取指定date的日期date_add(date,interval expr type) 返回一个日期/时间值加上一个时间间隔expr后的时间值datediff(date1,date2) 返回起始时间date1和结束时间date2之间的天数</code></pre><h2 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h2><pre><code class="mysql">if(value,t,t) 如果value为true，则返回t，否则返回fifnull(value1,value2) 如果value1不为空，返回value1，否则返回value2case when [val1] then [res1] ...else [default] end 如果val1为true，返回res1，否则返回default默认值case [expr] when [val1] then [res1] ...else [default] end 如果expr的值等于val1，返回res1，否则返回default默认值</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql-dcl</title>
      <link href="/2023/08/25/mysql-dcl/"/>
      <url>/2023/08/25/mysql-dcl/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库基本操作-dcl"><a href="#数据库基本操作-dcl" class="headerlink" title="数据库基本操作-dcl"></a>数据库基本操作-dcl</h1><p>dcl：data control language，数据控制语言，用来管理数据库用户，控制数据库的访问权限。</p><h2 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h2><p>查询用户</p><pre><code class="mysql">use mysql；select * from user；</code></pre><p>创建用户</p><pre><code class="mysql">create user &#39;用户名&#39;@&#39;主机名&#39; identified by &#39;密码&#39;；</code></pre><p>修改用户密码</p><pre><code class="mysql">alter user &#39;用户名&#39;@&#39;主机名&#39; identified with mysql_native_password by &#39;新密码&#39;;</code></pre><p>删除用户</p><pre><code class="mysql">drop user &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>注意：主机名可以用%</p><h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><p>查询权限</p><pre><code class="msyql">show grants for &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>授予权限</p><pre><code class="mysql">grant 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;</code></pre><p>撤销权限</p><pre><code class="mysql">revoke 权限列表 on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql-dql</title>
      <link href="/2023/08/25/mysql-dql/"/>
      <url>/2023/08/25/mysql-dql/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql基本操作-dql"><a href="#mysql基本操作-dql" class="headerlink" title="mysql基本操作-dql"></a>mysql基本操作-dql</h1><p>dpl：data query language，用来查询数据库中表的记录。</p><p>语法：</p><pre><code class="mysql">select     字段列表from    表名列表where    条件列表group by    分组字段列表having    分组后条件列表order by    排序字段列表limit    分页参数</code></pre><ul><li><p>基本查询</p><pre><code class="mysql">select 字段列表 from 表名;select * from 表名;select 字段1[as 别名]... from 表名;select distinct 字段列表 from 表名;#去除重复操作</code></pre></li><li><p>条件查询（where）</p></li><li><p>聚合函数（count，max，min，avg，sum）</p><p>将一列数据作为一个整体，进行纵向计算（null值不参与聚合函数的运算）</p><pre><code class="mysql">select 聚合函数(字段列表) from 表名;</code></pre></li><li><p>分组查询（group by）</p><pre><code class="mysql">select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后过滤条件];</code></pre><p>where和having区别</p><p>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。</p><p>判断条件不同：where不能对聚合函数进行判断，而having可以。</p></li><li><p>排序查询（order by）</p><pre><code class="mysql">select 字段列表 from 表名 order by 字段1 排序方式,字段2 排序方式;# asc 升序，desc 降序</code></pre></li><li><p>分页查询（limit）</p><pre><code>select 字段列表 from 表名 limit 起始索引,查询记录数;</code></pre></li></ul><p>dql执行顺序<br>from-&gt;where-&gt;group by-&gt;having-&gt;select-&gt;order by-&gt;limit</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql-dml</title>
      <link href="/2023/08/25/mysql-dml/"/>
      <url>/2023/08/25/mysql-dml/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql数据库基本操作-dml"><a href="#mysql数据库基本操作-dml" class="headerlink" title="mysql数据库基本操作-dml"></a>mysql数据库基本操作-dml</h1><p>dml：data manipulation language，用来对数据库中表的数据记录进行增删改操作</p><h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><pre><code class="mysql">给指定字段添加数据insert into 表名 (字段名1,字段名2) values (值1,值2,...);给全部字段添加数据insert into 表名 values ();批量添加数据insert into 表名 () values (),();insert into 表名 values (),();</code></pre><p>注意：</p><ul><li>字段顺序和值的顺序一一对应</li><li>字符串和日期型数据应该包含在引号中</li><li>数据大小在字段的规定范围中</li></ul><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><pre><code class="mysql">update 表名 set 字段名1=值1 [where 条件];</code></pre><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><pre><code class="mysql">delete from 表名 [where 条件];</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql-ddl</title>
      <link href="/2023/08/25/mysql-ddl/"/>
      <url>/2023/08/25/mysql-ddl/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql数据库基本操作-ddl"><a href="#mysql数据库基本操作-ddl" class="headerlink" title="mysql数据库基本操作-ddl"></a>mysql数据库基本操作-ddl</h1><h2 id="对数据库的常用操作"><a href="#对数据库的常用操作" class="headerlink" title="对数据库的常用操作"></a>对数据库的常用操作</h2><table><thead><tr><th>功能</th><th>sql</th></tr></thead><tbody><tr><td>查看所有的数据库</td><td>show databases;</td></tr><tr><td>创建数据库</td><td>create database [if not exists] mydb [charset&#x3D;utf8];</td></tr><tr><td>切换数据库</td><td>use mydb;</td></tr><tr><td>删除数据库</td><td>drop database [if exists] mydb;</td></tr></tbody></table><h2 id="对表结构的常用操作"><a href="#对表结构的常用操作" class="headerlink" title="对表结构的常用操作"></a>对表结构的常用操作</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><pre><code class="mysql">create table 表名(    字段名1 类型[(宽度)] [约束条件] [comment &#39;字段说明&#39;],    字段名2 类型[(宽度)] [约束条件] [comment &#39;字段说明&#39;],    ...)[表的一些设置];</code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>常用</p><table><thead><tr><th>tinyint</th><th>1byte</th><th>(-128,127)</th><th>(0,255)</th></tr></thead><tbody><tr><td>smallint</td><td>2</td><td>(-32768,32767)</td><td>(0,65535)</td></tr><tr><td>mediumint</td><td>3</td><td>(-8388608,8388607)</td><td>(0,16777215)</td></tr><tr><td>int&#x2F;integer</td><td>4</td><td>(-2147483648,2147483647)</td><td>(0,4294967295)</td></tr><tr><td>bigint</td><td>8</td><td></td><td></td></tr><tr><td>float</td><td>4</td><td></td><td></td></tr><tr><td>double</td><td>8</td><td></td><td></td></tr><tr><td>decimal</td><td></td><td>依赖与M和D的值</td><td>依赖与M和D的值</td></tr><tr><td>vachar</td><td>0-65532</td><td>变长字符串</td><td></td></tr><tr><td>char</td><td>0-255</td><td>定长字符串</td><td></td></tr><tr><td>date（日期值）</td><td>3</td><td>1000-01-01至9999-12-31</td><td>YYYY-MM-DD</td></tr><tr><td>time（时间值或持续时间）</td><td>3</td><td>-838:59:59至838:59:59</td><td>HH:MM:SS</td></tr><tr><td>datetime</td><td>8</td><td></td><td>YYYY-MM-DD HH:MM:SS</td></tr></tbody></table><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p>添加字段</p><pre><code class="mysql">alter table 表名 add 字段名1 类型[(宽度)] [约束条件] [comment &#39;字段说明&#39;];</code></pre><p>修改数据类型</p><pre><code class="mysql">alter table 表名 modify 字段名 新数据类型（长度）;</code></pre><p>修改字段名和字段类型</p><pre><code class="mysql">alter table 表名 change 旧字段名 新字段名 类型（长度） [comment &#39;字段说明&#39;] [约束];</code></pre><p>删除字段</p><pre><code class="mysql">alter table 表名 drop 字段名;</code></pre><p>修改表名</p><pre><code class="mysql">alter table 表名 rename to 表名;</code></pre><p>删除表</p><pre><code class="mysql">drop table [if exists] 表名;</code></pre><p>删除指定表，并重新创建该表</p><pre><code class="mysql">truncate table 表名</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>constructTree</title>
      <link href="/2023/06/12/constructTree/"/>
      <url>/2023/06/12/constructTree/</url>
      
        <content type="html"><![CDATA[<h1 id="三种遍历方式构造二叉树的通解"><a href="#三种遍历方式构造二叉树的通解" class="headerlink" title="三种遍历方式构造二叉树的通解"></a>三种遍历方式构造二叉树的通解</h1><h2 id="不同之处一：寻找当前根节点"><a href="#不同之处一：寻找当前根节点" class="headerlink" title="不同之处一：寻找当前根节点"></a>不同之处一：寻找当前根节点</h2><ul><li><p>前+中</p><p>当前根节点为pre[pre_start]，找出它在中序中的位置，然后把左右子树分开。</p></li><li><p>中+后</p><p>当前根节点为post[post_end]，找出它在中序中的位置，然后把左右子树分开。</p></li><li><p>前+后</p><p>当前根节点为pre[pre_start]，并在他在后序中的位置为post_end；左子树的根节点为pre[pre_start+1]，因此只要找到他在后序中的位置就可以分开左右子树</p></li></ul><h2 id="不同之处二：左右遍历范围"><a href="#不同之处二：左右遍历范围" class="headerlink" title="不同之处二：左右遍历范围"></a>不同之处二：左右遍历范围</h2><ul><li>前+中<br>中序遍历中，我们知道 左子树：[inorder_start,index-1], 右子树：[index+1, inorder_end]<br>在前序遍历中，左子树起始位置为pre_start+1,左子树一共有(index-1 - inorder_start)个，因此左子树：[pre_start+1, pre_start+1 + (index-1 - inorder_start)]<br>右子树起始位置为左子树终止位置+1，终止位置为pre_end，因此右子树：[ pre_start+1 + (index-1 - inorder_start) + 1, pre_end]</li><li>中+后<br>中序遍历中，我们知道 左子树：[inorder_start,index-1], 右子树：[index+1, inorder_end]<br>在后序遍历中，左子树起始位置为post_start，左子树一共有(index-1 - inorder_start)个，因此左子树：[post_start, post_start + (index-1 - inorder_start)]<br>右子树的终止位置为post_end - 1,右子树一共有(inorder_end - (index+1))个,因此右子树:[post_end - 1 - (inorder_end - (index+1)), post_end - 1]</li><li>前+后<br>后序遍历中，我们知道 左子树：[post_start,index], 右子树：[index+1, post_end-1]<br>在前序遍历中，左子树起始位置为pre_start+1,左子树个数一共有(index - post_start)个，因此左子树：[pre_start+1, pre_start+1 + (index - post_start)]<br>右子树起始位置为左子树终止位置+1，终止位置为pre_end，因此右子树：[ pre_start+1 + (index - post_start) + 1, pre_end]</li></ul><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code class="java">//从前序和中序遍历序列构造二叉树class Solution &#123;    private Map&lt;Integer,Integer&gt; indexMap;    int rootIndex=0;    public TreeNode myBuildTree(int[] preorder,int[] inorder,int preorderLeft,int preorderRight)&#123;        if(preorderLeft&lt;=preorderRight)&#123;            int rootVal=preorder[rootIndex++];            TreeNode root=new TreeNode(rootVal);            root.left=myBuildTree(preorder,inorder,preorderLeft,indexMap.get(rootVal)-1);            root.right=myBuildTree(preorder,inorder,indexMap.get(rootVal)+1,preorderRight);            return root;        &#125;else&#123;            return null;        &#125;    &#125;    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;        int n=preorder.length;        indexMap=new HashMap&lt;&gt;();        for(int i=0;i&lt;n;i++)&#123;            indexMap.put(inorder[i],i);        &#125;        return myBuildTree(preorder,inorder,0,n-1);    &#125;&#125;//从中序和后序遍历序列构造二叉树class Solution &#123;    Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;();    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;        int n=inorder.length;        for(int i=0;i&lt;n;i++)&#123;            map.put(inorder[i],i);        &#125;        return myBuildTree(inorder,postorder,0,n-1,0,n-1);    &#125;    public TreeNode myBuildTree(int[] inorder,int[] postorder,int inorderLeft,int inorderRight,int postorderLeft,int postorderRight)&#123;        if (postorderLeft &gt; postorderRight) &#123;            return null;        &#125;        int postorderRoot = postorderRight;        // 在中序遍历中定位根节点        int inorderRoot = map.get(postorder[postorderRoot]);                // 先把根节点建立出来        TreeNode root = new TreeNode(postorder[postorderRoot]);        // 得到左子树中的节点数目        int size_left_subtree = inorderRoot - inorderLeft;                root.left = myBuildTree(inorder, postorder, inorderLeft,inorderRoot-1, postorderLeft, postorderLeft+size_left_subtree-1);                root.right = myBuildTree(inorder, postorder, inorderRoot+1, inorderRight, postorderLeft+size_left_subtree, postorderRight-1);        return root;    &#125;&#125;//从前序和后序遍历构造二叉树class Solution &#123;    Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;();    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) &#123;        int n=postorder.length;        for(int i=0;i&lt;n;i++)&#123;            map.put(postorder[i],i);        &#125;        return myBuildTree(preorder,postorder,0,n-1,0,n-1);    &#125;    public TreeNode myBuildTree(int[] preorder,int[] postorder,int preorderL,int preorderR,int postorderL,int postorderR)&#123;        if(preorderL&gt;postorderR)&#123;            return null;        &#125;        TreeNode root=new TreeNode(preorder[preorderL]);        int leftSize=map.get(preorder[preorderL+1])-postorderL+1;        root.left=myBuildTree(preorder,postorder,preorderL+1,preorderL+leftSize,postorderL,postorderL+leftSize-1);        root.right=myBuildTree(preorder,postorder,preorderL+leftSize+1,preorderR,postorderL+leftSize,postorderR-1);        return root;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> construct </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm-class-loading-process</title>
      <link href="/2023/05/24/jvm-class-loading-process/"/>
      <url>/2023/05/24/jvm-class-loading-process/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="/..%5Cimages%5C68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f6a766d2f6c6966656379636c652d6f662d612d636c6173732e706e67" alt="img"></p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>上图中的加载-&gt;连接-&gt;初始化，连接过程又分为三步：验证-&gt;准备-&gt;解析</p><ul><li><p>加载</p><ol><li><p>通过类名获取此类的二进制字节流</p></li><li><p>将字节流代表的静态存储结构转换为方法区的运行时数据结构</p></li><li><p>在内存中生成一个代表该类的class对象，作为方法区这些数据的访问入口</p></li></ol></li></ul><p>每个java类都有一个引用指向加载它的ClassLoader。但是数组类不是通过ClassLoader创建的，而是JVM在需要的时候自动创建的，数组类通过getClassLoader()方法获取ClassLoader的时候和该数组的元素类型的ClassLoader是一致的。非数组类的加载阶段是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的loadClass()）。加载阶段和连接阶段的部分动作是交叉进行的，加载阶段尚未结束，连接阶段就有可能开始了。</p><pre><code class="java">class Class&lt;T&gt; &#123;  ...  private final ClassLoader classLoader;  @CallerSensitive  public ClassLoader getClassLoader() &#123;     //...  &#125;  ...&#125;</code></pre><h3 id="类加载器加载规则"><a href="#类加载器加载规则" class="headerlink" title="类加载器加载规则"></a>类加载器加载规则</h3><p>根据需要动态加载。对于已经加载的类会被加载在ClassLoader中。</p><pre><code class="java">public abstract class ClassLoader &#123;  ...  private final ClassLoader parent;  // 由这个类加载器加载的类。  private final Vector&lt;Class&lt;?&gt;&gt; classes = new Vector&lt;&gt;();  // 由VM调用，用此类加载器记录每个已加载类。  void addClass(Class&lt;?&gt; c) &#123;        classes.addElement(c);   &#125;  ...&#125;</code></pre><h3 id="类加载器总结"><a href="#类加载器总结" class="headerlink" title="类加载器总结"></a>类加载器总结</h3><p><img src="/..%5Cimages%5C68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f6a766d2f636c6173732d6c6f616465722d706172656e74732d64656c65676174696f6e2d6d6f64656c2e706e67" alt="img"></p><p>除了BootstrapClassLoader是JVM本身的一部分，其他所有的类加载器都是在JVM外部实现的，并且全部继承自ClassLoader抽象类。这与做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。</p><ul><li><p>连接</p><ol><li><p>验证</p><p>确保Class文件的字节流中包含的信息符合所有约束条件，保证信息被当作代码运行后不会危害虚拟机自身的安全。</p><p><img src="/..%5Cimages%5C68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f6a766d2f636c6173732d6c6f6164696e672d70726f636573732d766572696669636174696f6e2e706e67" alt="img"></p></li><li><p>准备</p><p>正式为类变量分配内存并设置类变量初始值的阶段</p></li><li><p>解析</p><p>虚拟机将常量池内的符号引用替换为直接引用的过程</p></li></ol></li><li><p>初始化</p><p>是执行初始化方法<clinit>()方法的过程，是类加载的最后一步，这一步JVM才开始真正执行类中定义的Java程序代码（字节码）</p><h2 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h2><p>卸载类即该类的Class对象被GC</p><p>三个条件：</p><ol><li>该类的而所有实例对象被GC，也就是是堆中不存在该类的实例对象</li><li>该类在任何地方被引用</li><li>该类的类加载器的实例被GC</li></ol><p>因此，在JVM的生命周期中，由jvm自带的类加载器加载的类是不会被卸载的，但是由我们自定义的类加载器加载的类是可能被卸载的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm-learn</title>
      <link href="/2023/05/23/jvm-learn/"/>
      <url>/2023/05/23/jvm-learn/</url>
      
        <content type="html"><![CDATA[<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><h2 id="运行数据区域"><a href="#运行数据区域" class="headerlink" title="运行数据区域"></a>运行数据区域</h2><p>JDK1.7</p><p><img src="/../images/image-20230523163329596.png" alt="image-20230523163329596"></p><p>JDK1.8</p><p><img src="/../images%5Cimage-20230523163752233.png" alt="image-20230523163752233"></p><h1 id="JVM回收"><a href="#JVM回收" class="headerlink" title="JVM回收"></a>JVM回收</h1><p>JDK1.7</p><p><img src="/../images%5Cjdk1.7%E5%A0%86%E7%BB%93%E6%9E%84.png" alt="image-20230523163752233"></p><ul><li>新生代</li><li>老生代</li><li>永久代</li></ul><p>JDK1.8</p><p><img src="/..%5Cimages%5Cimage-20230523164208008.png" alt="image-20230523164208008"></p><ul><li>新生代</li><li>老生代</li><li>元空间</li></ul><h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><h4 id="如果判断一个常量为废弃常量"><a href="#如果判断一个常量为废弃常量" class="headerlink" title="如果判断一个常量为废弃常量"></a>如果判断一个常量为废弃常量</h4><p>JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区，此时hotspot对方法区的实现为永久代</p><p>JDK1.7字符串常量池被从方法区拿到了堆中，这里没有提高运行时常量池，也就是说字符串常量池被单独拿到了堆，运行常量池剩下的东西还在方法区，也就是永久代</p><p>JDK1.8 hotspot移除永久代用元空间代替，这个时候字符串常量池还在堆中，运行时常量池还在方法区，但方法区的实现从永生代变为了元空间。</p><p>假设字符串常量池中存在字符“abc”，如果当前没有任何String对象引用该常量，就说明此常量是废弃常量，如果此时发生内存回收的话而且有必要的话，“abc”就会被清楚</p><h4 id="如果判断一个类是无用的类"><a href="#如果判断一个类是无用的类" class="headerlink" title="如果判断一个类是无用的类"></a>如果判断一个类是无用的类</h4><p>满足三个条件</p><ol><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例</li><li>加载该类的classLoader被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ol><p>如果满足上述条件虚拟机可以对类进行回收，但并不是像对象一样不使用了就必然被回收</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>debug-skill</title>
      <link href="/2023/05/12/debug-skill/"/>
      <url>/2023/05/12/debug-skill/</url>
      
        <content type="html"><![CDATA[<h1 id="idea中利用条件判断快速定位列表元素"><a href="#idea中利用条件判断快速定位列表元素" class="headerlink" title="idea中利用条件判断快速定位列表元素"></a>idea中利用条件判断快速定位列表元素</h1><p>例如在发布问题默认用户时，假设首先通过页面控制台得到question.id&#x3D;&#x3D;3</p><p>我们此时找到QuestionService中 list方法，</p><pre><code class="java">for (Question question : questions) &#123;            User user = userMapper.selectByPrimaryKey(question.getCreator());            QuestionDTO questionDTO = new QuestionDTO();            BeanUtils.copyProperties(question, questionDTO);            questionDTO.setUser(user);            questionDTOList.add(questionDTO);        &#125;</code></pre><p>在第二句中打上断点，并加入condition如下图</p><p><img src="/../images/image-20230512124224225.png" alt="image-20230512124224225"></p><p>即可直接在id为3时调试bug</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> idea </category>
          
          <category> debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debug </tag>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git-learning</title>
      <link href="/2023/05/10/git-learning/"/>
      <url>/2023/05/10/git-learning/</url>
      
        <content type="html"><![CDATA[<h1 id="git命令学习"><a href="#git命令学习" class="headerlink" title="git命令学习"></a>git命令学习</h1><p>初始化文件夹</p><pre><code class="shell">git init</code></pre><p>添加新文件</p><pre><code class="shell">git add .git add filenamegit add -am</code></pre><p><code>git commit -am</code> 的作用是将所有已经被 Git 管理的文件添加到暂存区并提交这些变更，并且可以通过 <code>-m</code> 参数指定提交消息。需要注意的是，如果有新文件或未被 Git 管理的文件需要添加到仓库中，还需要使用 <code>git add</code> 命令将它们添加到暂存区中。</p><p>提交版本</p><pre><code class="shell">git commit -m &quot;说明&quot;</code></pre><p>在本地的git仓库添加远程仓库</p><pre><code class="shell">git remote add origin [url]</code></pre><p>发布版本</p><pre><code class="shell">git push origin mastergit push --set-upstream origin [branch]</code></pre><p>origin其实就是远程仓库地址，master就是分支。在.git文件夹中的config都可以修改。</p><p>拉去到本地仓库</p><ul><li><p>默认合并</p><pre><code class="shell">git pull</code></pre></li><li><p>非默认</p><pre><code class="shell">git pull [url]</code></pre></li><li><p>拉取所有分支</p></li></ul><pre><code class="shell">git fetch</code></pre><p>创建分支</p><pre><code class="shell">git branch (name)</code></pre><p>切换分支</p><pre><code class="shell">git checkout (name)</code></pre><p>创建分支并切换到该分支</p><pre><code class="shell">git checkout -b (name)</code></pre><p>删除分支</p><pre><code class="shell">git branch -d (name)</code></pre><p>合并分支</p><pre><code class="shell">git merge (name)</code></pre><p>将(name)分支合并到当前所在分支，此处通常当分支&#x2F;测试分支有了独立内容，希望合并的时候，也就是测试正确的时候合并到当前分支。合并完后一般删除分支</p><p>撤回到某个版本（在还没push之前）</p><pre><code class="shell">git reset HEAD</code></pre><p>合并到上一次commit中</p><pre><code class="shell">git add .git commit --amend</code></pre><h2 id="git-error"><a href="#git-error" class="headerlink" title="git error"></a>git error</h2><ul><li><p>ssh: connect to host github.com port 22: Connection timed out fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists.</p><p>解决方法：</p><ol><li><p>修改.git文件中的config文件将origin的url换为http地址</p></li><li><p>修改端口号</p><pre><code class="shell">cd ~/.sshvim congfig</code></pre></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis:MapperXML文件报错(Unable to resolve table &#39;limit&#39;)</title>
      <link href="/2023/05/10/MybatisMapperXML%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99/"/>
      <url>/2023/05/10/MybatisMapperXML%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis-MapperXML文件报错-Unable-to-resolve-table-‘limit’"><a href="#Mybatis-MapperXML文件报错-Unable-to-resolve-table-‘limit’" class="headerlink" title="Mybatis:MapperXML文件报错(Unable to resolve table ‘limit’)"></a>Mybatis:MapperXML文件报错(Unable to resolve table ‘limit’)</h1><p>在使用<where><if></if></where>时报错</p><pre><code class="javascript">&lt;select id=&quot;selectBySearch&quot; parameterType=&quot;life.mhe.community.dto.QuestionQueryDTO&quot; resultMap=&quot;BaseResultMap&quot;&gt;        select * from question        &lt;where&gt;            &lt;if test=&quot;search!=null&quot;&gt;                 title regexp #&#123;search&#125;            &lt;/if&gt;        &lt;/where&gt;        order by gmt_create desc limit #&#123;page&#125;,#&#123;size&#125;    &lt;/select&gt;</code></pre><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>起初将where和if交换位置依旧报错</p><p>类似问题：</p><p>[]: <a href="https://stackoverflow.com/questions/60575770/">https://stackoverflow.com/questions/60575770/</a></p><p>最终将标签<where>改为where关键字解决</p><pre><code class="javascript">where            &lt;if test=&quot;search!=null&quot;&gt;                 title regexp #&#123;search&#125;            &lt;/if&gt;        order by gmt_create desc limit #&#123;page&#125;,#&#123;size&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-最长回文子串</title>
      <link href="/2023/05/10/leetcode-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2023/05/10/leetcode-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>解法：动态规划</p><pre><code class="java">public class Solution &#123;    public String longestPalindrome(String s) &#123;        int len = s.length();        if (len &lt; 2) &#123;            return s;        &#125;        int maxLen = 1;        int begin = 0;        // dp[i][j] 表示 s[i..j] 是否是回文串        boolean[][] dp = new boolean[len][len];        // 初始化：所有长度为 1 的子串都是回文串        for (int i = 0; i &lt; len; i++) &#123;            dp[i][i] = true;        &#125;        char[] charArray = s.toCharArray();        // 递推开始        // 先枚举子串长度        for (int L = 2; L &lt;= len; L++) &#123;            // 枚举左边界，左边界的上限设置可以宽松一些            for (int i = 0; i &lt; len; i++) &#123;                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得                int j = L + i - 1;                // 如果右边界越界，就可以退出当前循环                if (j &gt;= len) &#123;                    break;                &#125;                if (charArray[i] != charArray[j]) &#123;                    dp[i][j] = false;                &#125; else &#123;                    if (j - i &lt; 3) &#123;                        dp[i][j] = true;                    &#125; else &#123;                        dp[i][j] = dp[i + 1][j - 1];                    &#125;                &#125;                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置                if (dp[i][j] &amp;&amp; j - i + 1 &gt; maxLen) &#123;                    maxLen = j - i + 1;                    begin = i;                &#125;            &#125;        &#125;        return s.substring(begin, begin + maxLen);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-use</title>
      <link href="/2023/05/09/hexo-use/"/>
      <url>/2023/05/09/hexo-use/</url>
      
        <content type="html"><![CDATA[<h2 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h2><p>hexo new &lt;&gt;</p><p>git<br>git add .<br>git commit -m “”<br>git push origin public</p><p>发布网站并推送静态文件到master分支<br>hexo g -d</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
